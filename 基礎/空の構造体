// 空の構造体はフィールドを持たない構造体型です
type Q struct{} // 名前付け
var q struct{}  // 匿名

// unsafe.Sizeof()を使用すると型のサイズを知ることができる
var s string
var c complex128
fmt.Println(unsafe.Sizeof(s)) // prints 8
fmt.Println(unsafe.Sizeof(c)) // prints 16

// 配列型のサイズはその要素型の倍数です。
var a [3]uint32
fmt.Println(unsafe.Sizeof(a)) // prints 12

// 複合型のサイズは、構成型のサイズの合計とパディングです。
type S struct {
	a uint16
	b uint32
}
var s S
fmt.Println(unsafe.Sizeof(s)) // prints 8, not 6

// 空の構造体は0バイトしか消費しないため、パディングは不要です。
// したがって、struct空の構造体で構成される構造体もストレージを消費しません。
var s struct{}
fmt.Println(unsafe.Sizeof(s)) // prints 0

// 配列を宣言することはできますが、もちろんストレージは消費しません
var x [1000000000]struct{}
fmt.Println(unsafe.Sizeof(x)) // prints 0

// スライスはスライスヘッダーの領域のみを消費します。
var x = make([]struct{}, 1000000000)
fmt.Println(unsafe.Sizeof(x)) // prints 12 in the playground

// 他の値と同様に、アドレス指定可能な場合は値のアドレスを取得できます。
var a struct{}
var b = &a

// 興味深いことに、2つの値のアドレスは同じである場合があります。
var a, b struct{}
fmt.Println(&a == &b) // true

// この特性はスライスでも観測可能
a := make([]struct{}, 10)
b := make([]struct{}, 20)
fmt.Println(&a == &b)       // false, a and b are different slices
fmt.Println(&a[0] == &b[0]) // true, their backing arrays are the same

// 空の構造体にはフィールドがないので、データを保持できません。
// 空の構造体にデータが含まれていない場合、2つのstruct{}値が異なるかどうかを判断できません。
// つまり、実質的には代替可能（fungible）なのです。
a := struct{}{} // not the zero value, a real new struct{} instance
b := struct{}{}
fmt.Println(a == b) // true

// 空の構造体が他の型と同じように動作することを実証したので、それをメソッドレシーバーとして使用することもできます。
type S struct{}

func (s *S) addr() { fmt.Printf("%p\n", s) }

func main() {
        var a, b S
        a.addr() // 0x1beeb0
        b.addr() // 0x1beeb0
}
